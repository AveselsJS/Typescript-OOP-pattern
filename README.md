# Шаблоны проектирования

Шаблоны проектирования помогают нам унифицировать код под уже существующие лучшие практики. Используя нужный шаблон проектирования в определёной ситуации формирует стерильный код. Здесь описаны в общей сумме 17 паттернов: порождающие, структурные и поведенческие.

## Оглавление
- [Шаблоны проектирования](#шаблоны-проектирования)
  - [Оглавление](#оглавление)
  - [Порождающие паттерны](#порождающие-паттерны)
    - [Singleton (Одиночка)](#singleton-одиночка)
    - [Prototype (Прототип)](#prototype-прототип)
    - [Builder (Строитель)](#builder-строитель)
    - [Factory (Фабрика)](#factory-фабрика)
  - [Структурные паттерны:](#структурные-паттерны)
    - [Bridge (Мост)](#bridge-мост)
    - [Facade (Фасад)](#facade-фасад)
    - [Adapter (Адаптер)](#adapter-адаптер)
    - [Proxy (Прокси)](#proxy-прокси)
    - [Composite (Композит)](#composite-композит)

## Порождающие паттерны

Порождающие паттерны - это шаблоны, которые описают создание объектов.

### Singleton (Одиночка)

Данный шаблон необходимо применять, когда необходим лишь один экземпляр класса, например для методов, которые описывают конфигурацию или создают CRUDGeneric класс. <br/> <br/>
Суть паттерна - описывать методы класса через модификаторы *public* и *static*. Таким образом с помощью модификатора *public* методы будут доступны всем, а модификатор *static*, позволяет получать доступ к методам класса без создаеия экземпляра класса. 

Пример реализации: [Singleton](creational_patterns/Singleton.ts)

### Prototype (Прототип)

Данный шаблон применяется когда необходимо склонировать полностью другой класс не углубляюсь в реализацию этого класса. <br/> <br/>
Суть паттерна - создать метод внутри класса, который позволяет полностью скоппировать другой класс. 

Пример реализации: [Prototype](creational_patterns/Prototype.ts)

### Builder (Строитель) 
Данный шаблон применяется, когда необходимо создавать большие объекты с разными конфигурациями или фильтрами. Отличный пример это объект позволяющий сделать объект запроса к базе данных. <br/> <br/>
Суть паттерна - создать большое количество простых методов, через модификатор *public*, которые можно будет последовательно через точку реализовывать на объекте. Например методы фильтрации данных приходящих из базы данных.

Пример реализации: [Builder](creational_patterns/Builder.ts)

### Factory (Фабрика) 
Данный шаблон применяется при создании возможности на основе базового класса создавать разные системы, которые подключаются к базовому классу через единый базовый интерфейс этого класса. <br/> <br/>
Суть паттерна - создать базовый класс системы и описать API к подключению этой системы, после чего от этого базового класса системы наследовать все методы API для подключения и описания конкретной другой системы.
Примеры реализации: <br/>
1. Система отправки товара интернет-магазина, как базовая система со своим API, от которой могут наследоватся системы описывающее реализацию отправку Новой Почтой, Укрпочтой, или отправка курьером. <br/> <br/>
2. Система страхования, которая является базовым классом API и от которой наследуются классы описывающее разные виды страховых компаний, которыми может воспользоватся пользователь: например система MetLife, Спутник или Alicoaglife.

Пример реализации: [Factory](creational_patterns/Factory.ts)

## Структурные паттерны:

Структурные паттерны - это шаблоны проектирования, которые типизируют структурирования кода.

### Bridge (Мост)
Данный шаблон примерчется, когда есть потребность реализовать однаковые формат API, для разных сервисов, которые выполняют одну и ту же функциональность. <br/> <br/> 
Суть паттерна: <br/> 
Создать общий интерфейс для каждого из класса сервиса, где описать все методы API. Реализовать каждый класс, такого сервиса через имплементацию этого интерфейса, после чего реализовать класс, в конструктор которого передается этот же интерфейс и в общие методы API группируются в один метод, приэтом этот метод в себе ссылается на this аргумента реализующиц этот интерфейс. <br/> <br/> 
Пример реализации: <br/>
Приложение, по отправке сообщений. Приэтом оно должно реализовывать функциональность мгновенных и отложенных сообщений, а так же реализовывать эту функциональность для разного типа месседжеров, таких как Telegram, WatchApp или Viber.

### Facade (Фасад) 
Данный шаблон применяется, когда необходимо за простым API спрятать перечень сервисов или несколько бизнес-логик, которые не связаны между собой. <br/> <br/> 
Суть паттерна - создать классы сервисов, которые должны быть реализованы в ходе работы примитивного действия и создания класса, который реализовывает простой API интерфейс и под колпаком которого, внедряются экземпляры классов различных сервисов. Эти сервисы внедряются с модификатором *private* поскольку сервисы должны быть инкапсулированы и не должны быть допустимы к использованию вне класса. <br/> <br/> 
Пример реализации: <br/> 
Клавиша отправки уведомления на почту, которая под капотом имеет сайд эффект в виде логгирования (добавления реализации LoggerService), сервиса автологгирования, который автоматически подтягивает данные из регистрации, как данные для логирования в почтовом сторонеем сервисе (LoginService) и, к примеру, реализация сервиса шаблона, который реализовывает разметку данного типа уведомления (MailService). <br/> <br/> 

### Adapter (Адаптер) 
Данный шаблон используется, когда необходимо подсоединить два различных класса с различными типами данных. <br/> <br/> 
Суть паттерна - создать или получить класс который имеет неподходящий тип данных для портирования (соединения с другим классом). Создать класс, который бы наследовался от этого класса, который внутри своего конструктора принимает класс, к которому нужно адаптить, после чего внутри такого класса создать метод, который бы уже реализовывал приходящие данные неадаптированого класса в нужный нам формат. <br/> <br/> 
Пример реализации: <br/> 
Получение данных от стороннего сервиса, и которые необходимо как-то обработать, для получения необходимого формата данных, которые пользуются другим сторонним сервисом. 

### Proxy (Прокси) 
Данный шаблон используется, когда необходимо с работой отдельно взятого класса, происходили сопутствующие действия (side effects). <br/> <br/> 
Суть паттерна: <br/> 
Создать общий интерфейс, который имплементит каждый из классов: класс, который выполняет логику и класс, который проксирует свою логику поверх первого класса. Необходимо понимать, что Proxy не расширяет один класс другим, как при классическом extends, а именно что оборачивает одну логику поверх другой. <br/> <br/> 
Пример реализации: <br/> 
Получение данных из базы данных, только если данные пользователя подходят под авторские права. Так логику доступа к базе данных описывается в просто классе, а логика проверки на соответствие пользователя в классе, который проксирует первый.

### Composite (Композит) 
Данный шаблон используется при реализации древовидных бизнес-логик и инкапсулирования их в простое API. <br/> 
Суть паттерна: <br/> 
Создать абстрактный класс с абстрактными методами, которые наследуются разными вариантами реалзиации абстрактного класса, в ходе описания реализующих классов абстрактные классы перезаписываются и модифицируются модификатором *overrite*, для защиты от исчезновения методов в абстрактном классе. После чего создается результирующий класс, который реализовывает те же абстрактные методы в простое API. <br/> <br/> 
Пример реализации: <br/> 
Интернет-магазин имеет возможность продажи как в готовой заводской упаковке - первая ветка дерева, так и самостоятельно упаковать несколько товаров - другая ветка дерева. Необходимо реализовать метод, который обходил бы дерево и давал итоговую стоимость как в случае с упаковкой так и без.
